{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FetalSynthGen Introduction FetalSynthGen is a synthetic data generator created to address the challenges of limited data and domain shifts in fetal brain MRI analysis. It is based on the domain randomization approach of SynthSeg [1], which uses anatomical segmentations to create diverse synthetic images. It's application for fetal brain tissue segmentation is described in [2, 3]. Below is a brief overview of the key components of the FetalSynthGen pipeline: Input: The generator begins with a dataset of segmentation maps, which serve as anatomical priors of the simulated fetal brain. Meta-Labels: Instead of directly using the original segmentation labels, the method first merges these labels into four meta-classes : white matter (WM), gray matter (GM), cerebrospinal fluid (CSF), and non-brain tissue (including skull and surrounding maternal tissue). Intensity Clustering: Within each meta-class, the generator uses the Expectation-Maximization (EM) algorithm for intensity clustering, which divides each meta-class into subclasses , capturing the heterogeneity of the simulated brain tissues. The number of subclasses is sampled from a random uniform distribution. Intensity Generation: For each subclass, the generator then samples intensities from a Gaussian Mixture Model (GMM) with randomized parameters. This method creates images with varied contrasts that although often exceed what is realistic, ensure that the model learns features robust to domain shifts related to intensity or contrast. Spatial Transformations: After generating intensities, the synthetic images undergo spatial transformations, including affine and non-rigid diffeomorphic deformations. These simulate variations in image resolution and partial volume effects. Artifact Simulation : The generator corrupts the images by adding a bias field, performing intensity transformations, and simulating various image resolutions. The output of the generator is a paired set of synthetic images and corresponding synthetic segmentations that can be used to train a segmentation model, super-resolution or brain-embedding model. Installation From Source git clone https://github.com/Medical-Image-Analysis-Laboratory/fetalsyngen cd fetalsyngen pip install -e . Acknowledgements This research was funded by the Swiss National Science Foundation (182602 and 215641), ERA-NET Neuron MULTI-FACT project (SNSF 31NE30 203977). We acknowledge the Leenaards and Jeantet Foundations as well as CIBM Center for Biomedical Imaging, a Swiss research center of excellence founded and supported by CHUV, UNIL, EPFL, UNIGE and HUG. References Billot, Benjamin, et al. \u201cSynthSeg: Segmentation of Brain MRI Scans of Any Contrast and Resolution without Retraining.\u201d Medical Image Analysis, vol. 86, 25 Feb. 2023, pp. 102789\u2013102789, www.sciencedirect.com/science/article/pii/S1361841523000506, https://doi.org/10.1016/j.media.2023.102789. Vladyslav Zalevskyi, et al. \u201cImproving Cross-Domain Brain Tissue Segmentation in Fetal MRI with Synthetic Data.\u201d Lecture Notes in Computer Science, 1 Jan. 2024, pp. 437\u2013447, link.springer.com/chapter/10.1007/978-3-031-72378-0_41, https://doi.org/10.1007/978-3-031-72378-0_41. Vladyslav Zalevskyi, et al. \u201cMaximizing Domain Generalization in Fetal Brain Tissue Segmentation: The Role of Synthetic Data Generation, Intensity Clustering and Real Image Fine-Tuning.\u201d ArXiv.org, 2024, arxiv.org/abs/2411.06842. \u200c \u200c \u200c","title":"FetalSynthGen GitHub"},{"location":"#fetalsynthgen","text":"","title":"FetalSynthGen"},{"location":"#introduction","text":"FetalSynthGen is a synthetic data generator created to address the challenges of limited data and domain shifts in fetal brain MRI analysis. It is based on the domain randomization approach of SynthSeg [1], which uses anatomical segmentations to create diverse synthetic images. It's application for fetal brain tissue segmentation is described in [2, 3]. Below is a brief overview of the key components of the FetalSynthGen pipeline: Input: The generator begins with a dataset of segmentation maps, which serve as anatomical priors of the simulated fetal brain. Meta-Labels: Instead of directly using the original segmentation labels, the method first merges these labels into four meta-classes : white matter (WM), gray matter (GM), cerebrospinal fluid (CSF), and non-brain tissue (including skull and surrounding maternal tissue). Intensity Clustering: Within each meta-class, the generator uses the Expectation-Maximization (EM) algorithm for intensity clustering, which divides each meta-class into subclasses , capturing the heterogeneity of the simulated brain tissues. The number of subclasses is sampled from a random uniform distribution. Intensity Generation: For each subclass, the generator then samples intensities from a Gaussian Mixture Model (GMM) with randomized parameters. This method creates images with varied contrasts that although often exceed what is realistic, ensure that the model learns features robust to domain shifts related to intensity or contrast. Spatial Transformations: After generating intensities, the synthetic images undergo spatial transformations, including affine and non-rigid diffeomorphic deformations. These simulate variations in image resolution and partial volume effects. Artifact Simulation : The generator corrupts the images by adding a bias field, performing intensity transformations, and simulating various image resolutions. The output of the generator is a paired set of synthetic images and corresponding synthetic segmentations that can be used to train a segmentation model, super-resolution or brain-embedding model.","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"#from-source","text":"git clone https://github.com/Medical-Image-Analysis-Laboratory/fetalsyngen cd fetalsyngen pip install -e .","title":"From Source"},{"location":"#acknowledgements","text":"This research was funded by the Swiss National Science Foundation (182602 and 215641), ERA-NET Neuron MULTI-FACT project (SNSF 31NE30 203977). We acknowledge the Leenaards and Jeantet Foundations as well as CIBM Center for Biomedical Imaging, a Swiss research center of excellence founded and supported by CHUV, UNIL, EPFL, UNIGE and HUG.","title":"Acknowledgements"},{"location":"#references","text":"Billot, Benjamin, et al. \u201cSynthSeg: Segmentation of Brain MRI Scans of Any Contrast and Resolution without Retraining.\u201d Medical Image Analysis, vol. 86, 25 Feb. 2023, pp. 102789\u2013102789, www.sciencedirect.com/science/article/pii/S1361841523000506, https://doi.org/10.1016/j.media.2023.102789. Vladyslav Zalevskyi, et al. \u201cImproving Cross-Domain Brain Tissue Segmentation in Fetal MRI with Synthetic Data.\u201d Lecture Notes in Computer Science, 1 Jan. 2024, pp. 437\u2013447, link.springer.com/chapter/10.1007/978-3-031-72378-0_41, https://doi.org/10.1007/978-3-031-72378-0_41. Vladyslav Zalevskyi, et al. \u201cMaximizing Domain Generalization in Fetal Brain Tissue Segmentation: The Role of Synthetic Data Generation, Intensity Clustering and Real Image Fine-Tuning.\u201d ArXiv.org, 2024, arxiv.org/abs/2411.06842. \u200c \u200c \u200c","title":"References"},{"location":"configs/","text":"Configs We use Hydra to manage configurations and instantiate classes in the FetalSynthGen pipeline. It allows us to define configurations in YAML files and instantiate classes with these configurations. This makes it easy to modify parameters and experiment with different settings. See the Hydra documentation for more information. Quick hydra overview Configuration files are stored in the configs directory. Each file is a .yaml file that contains the parameters for the generation pipeline and defines an instantiation of a class. Fields in the configuration files can be overridden from the command line or from other configuration files. Some special fields are: _target_ field in the configuration file specifies the class to be instantiated. All other fields are passed as arguments to the class constructor. It can be any callable object, including classes, functions, and lambdas, from any module in the Python path (local or external). defaults field in the configuration file specifies the default configuration file to be used, that is merged with the current configuration file. If a field is present in both files, the one in the current file takes precedence. For example defaults: - generator/default will load the generator/default.yaml file and will make all fields from the generator/default.yaml file available in the current configuration file from the generator.* namespace. null is used in the configuration files to specify a None value in Python. expressions like \"${var}\" can be used to access variable value in the same level of a given config while \"${..var}\" can be used to access variable value from the parent config. Configuration Files We provide a variety of ready-to-use configurations for different tasks. These configuration files are stored in the fetalsyngen/configs/dataset directory. To use them, copy the configuration files to your project root directory into configs/dataset . Feel free to modify these configurations to suit the specific requirements of your project. Validation/Testing Dataset Dataset configuration for loading real images and segmentations. Used for testing and validation on real data. See /datasets/#fetalsyngen.data.datasets.FetalTestDataset for more details. defaults : - transforms/inference _target_ : fetalsyngen.data.datasets.FetalTestDataset bids_path : ./data sub_list : null Real images with synthetic transformations Dataset configuration for applying the same transformations used in the generation of synthetic data to real images and segmentations. See /datasets/#fetalsyngen.data.datasets.FetalSynthDataset for more details. configs/dataset/real_train.yaml > defaults : - generator/default _target_ : fetalsyngen.data.datasets.FetalSynthDataset bids_path : ./data seed_path : null sub_list : null load_image : True image_as_intensity : True Synthetic images and segmentations Dataset configuration for creating synthetic images and segmentations on the fly. See /datasets/#fetalsyngen.data.datasets.FetalSynthDataset for more details. configs/dataset/synth_train.yaml > defaults : - generator/default _target_ : fetalsyngen.data.datasets.FetalSynthDataset bids_path : ./data seed_path : ./data/derivatives/seeds sub_list : null load_image : False image_as_intensity : False Default Generator Configuration configs/dataset/generator/default.yaml > _target_ : fetalsyngen.generator.model.FetalSynthGen shape : [ 256 , 256 , 256 ] resolution : [ 0.5 , 0.5 , 0.5 ] device : cuda # cuda ~6x faster than cpu intensity_generator : _target_ : fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds min_subclusters : 1 max_subclusters : 3 seed_labels : [ 0 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 ] generation_classes : [ 0 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 ] spatial_deform : _target_ : fetalsyngen.generator.deformation.affine_nonrigid.SpatialDeformation device : \"${..device}\" # uses the device from the generator size : ${..shape} # uses the shape from the generator flip_prb : 0.5 max_rotation : 20 max_shear : 0.02 max_scaling : 0.1 nonlinear_transform : True nonlin_scale_min : 0.03 nonlin_scale_max : 0.06 nonlin_std_max : 4 resampler : _target_ : fetalsyngen.generator.augmentation.synthseg.RandResample min_resolution : 1.9 max_resolution : 2 prob : 1 bias_field : _target_ : fetalsyngen.generator.augmentation.synthseg.RandBiasField prob : 1 scale_min : 0.004 scale_max : 0.02 std_min : 0.01 std_max : 0.3 gamma : _target_ : fetalsyngen.generator.augmentation.synthseg.RandGamma prob : 1 gamma_std : 0.1 noise : _target_ : fetalsyngen.generator.augmentation.synthseg.RandNoise prob : 1 std_min : 5 std_max : 15","title":"Configs"},{"location":"configs/#configs","text":"We use Hydra to manage configurations and instantiate classes in the FetalSynthGen pipeline. It allows us to define configurations in YAML files and instantiate classes with these configurations. This makes it easy to modify parameters and experiment with different settings. See the Hydra documentation for more information.","title":"Configs"},{"location":"configs/#quick-hydra-overview","text":"Configuration files are stored in the configs directory. Each file is a .yaml file that contains the parameters for the generation pipeline and defines an instantiation of a class. Fields in the configuration files can be overridden from the command line or from other configuration files. Some special fields are: _target_ field in the configuration file specifies the class to be instantiated. All other fields are passed as arguments to the class constructor. It can be any callable object, including classes, functions, and lambdas, from any module in the Python path (local or external). defaults field in the configuration file specifies the default configuration file to be used, that is merged with the current configuration file. If a field is present in both files, the one in the current file takes precedence. For example defaults: - generator/default will load the generator/default.yaml file and will make all fields from the generator/default.yaml file available in the current configuration file from the generator.* namespace. null is used in the configuration files to specify a None value in Python. expressions like \"${var}\" can be used to access variable value in the same level of a given config while \"${..var}\" can be used to access variable value from the parent config.","title":"Quick hydra overview"},{"location":"configs/#configuration-files","text":"We provide a variety of ready-to-use configurations for different tasks. These configuration files are stored in the fetalsyngen/configs/dataset directory. To use them, copy the configuration files to your project root directory into configs/dataset . Feel free to modify these configurations to suit the specific requirements of your project.","title":"Configuration Files"},{"location":"configs/#validationtesting-dataset","text":"Dataset configuration for loading real images and segmentations. Used for testing and validation on real data. See /datasets/#fetalsyngen.data.datasets.FetalTestDataset for more details. defaults : - transforms/inference _target_ : fetalsyngen.data.datasets.FetalTestDataset bids_path : ./data sub_list : null","title":"Validation/Testing Dataset"},{"location":"configs/#real-images-with-synthetic-transformations","text":"Dataset configuration for applying the same transformations used in the generation of synthetic data to real images and segmentations. See /datasets/#fetalsyngen.data.datasets.FetalSynthDataset for more details. configs/dataset/real_train.yaml > defaults : - generator/default _target_ : fetalsyngen.data.datasets.FetalSynthDataset bids_path : ./data seed_path : null sub_list : null load_image : True image_as_intensity : True","title":"Real images with synthetic transformations"},{"location":"configs/#synthetic-images-and-segmentations","text":"Dataset configuration for creating synthetic images and segmentations on the fly. See /datasets/#fetalsyngen.data.datasets.FetalSynthDataset for more details. configs/dataset/synth_train.yaml > defaults : - generator/default _target_ : fetalsyngen.data.datasets.FetalSynthDataset bids_path : ./data seed_path : ./data/derivatives/seeds sub_list : null load_image : False image_as_intensity : False","title":"Synthetic images and segmentations"},{"location":"configs/#default-generator-configuration","text":"configs/dataset/generator/default.yaml > _target_ : fetalsyngen.generator.model.FetalSynthGen shape : [ 256 , 256 , 256 ] resolution : [ 0.5 , 0.5 , 0.5 ] device : cuda # cuda ~6x faster than cpu intensity_generator : _target_ : fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds min_subclusters : 1 max_subclusters : 3 seed_labels : [ 0 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 ] generation_classes : [ 0 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 30 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 ] spatial_deform : _target_ : fetalsyngen.generator.deformation.affine_nonrigid.SpatialDeformation device : \"${..device}\" # uses the device from the generator size : ${..shape} # uses the shape from the generator flip_prb : 0.5 max_rotation : 20 max_shear : 0.02 max_scaling : 0.1 nonlinear_transform : True nonlin_scale_min : 0.03 nonlin_scale_max : 0.06 nonlin_std_max : 4 resampler : _target_ : fetalsyngen.generator.augmentation.synthseg.RandResample min_resolution : 1.9 max_resolution : 2 prob : 1 bias_field : _target_ : fetalsyngen.generator.augmentation.synthseg.RandBiasField prob : 1 scale_min : 0.004 scale_max : 0.02 std_min : 0.01 std_max : 0.3 gamma : _target_ : fetalsyngen.generator.augmentation.synthseg.RandGamma prob : 1 gamma_std : 0.1 noise : _target_ : fetalsyngen.generator.augmentation.synthseg.RandNoise prob : 1 std_min : 5 std_max : 15","title":"Default Generator Configuration"},{"location":"datasets/","text":"Datasets Classes for loading and processing datasets. Note \ud83d\udcdd Device : All datasets return samples with tensors on the CPU (even when the synthetic data generation is done on the GPU). This is due to restriction on the GPU usage in the multiprocessing settings, where GPU memory cannot be easily shared between processes. \ud83d\udcdd Dataloader : When using torch.utils.data.DataLoader ensure that you pass multiprocessing_context=\"spawn\" argument to the dataloader object when using FetalSynthDataset to ensure that the spawned processes have access to the GPU. FetalDataset Abstract class defining a dataset for loading fetal data. __init__ ( bids_path , sub_list ) Parameters: bids_path ( str ) \u2013 Path to the bids folder with the data. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used. FetalTestDataset Bases: FetalDataset Dataset class for loading fetal images offline. Used to load test/validation data. Use the transforms argument to pass additional processing steps (scaling, resampling, cropping, etc.). __init__ ( bids_path , sub_list , transforms = None ) Parameters: bids_path ( str ) \u2013 Path to the bids folder with the data. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used. transforms ( Compose | None , default: None ) \u2013 Compose object with the transformations to apply. Default is None, no transformations are applied. Note We highle recommend using the transforms arguments with at least the re-oriented transform to RAS and the intensity scaling to [0, 1] to ensure the data consistency. See inference.yaml for an example of the transforms configuration. __getitem__ ( idx ) Returns: dict \u2013 Dictionary with the image , label and the name keys. image and label are torch.float32 monai.data.meta_tensor.MetaTensor instances with dimensions (1, H, W, D) and name is a string of a format sub_ses where sub is the subject name and ses is the session name. reverse_transform ( data ) Reverse the transformations applied to the data. Parameters: data ( dict ) \u2013 Dictionary with the image and label keys, like the one returned by the __getitem__ method. Returns: dict \u2013 Dictionary with the image and label keys where the transformations are reversed. FetalSynthDataset Bases: FetalDataset Dataset class for generating/augmenting on-the-fly fetal images\" __init__ ( bids_path , generator , seed_path , sub_list , load_image = False , image_as_intensity = False ) Parameters: bids_path ( str ) \u2013 Path to the bids-formatted folder with the data. seed_path ( str | None ) \u2013 Path to the folder with the seeds to use for intensity sampling. See scripts/seed_generation.py for details on the data formatting. If seed_path is None, the intensity sampling step is skipped and the output image intensities will be based on the input image. generator ( FetalSynthGen ) \u2013 a class object defining a generator to use. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used. load_image ( bool , default: False ) \u2013 If True , the image is loaded and passed to the generator, where it can be used as the intensity prior instead of a random intensity sampling or spatially deformed with the same transformation field as segmentation and the syntehtic image. Default is False . image_as_intensity ( bool , default: False ) \u2013 If True , the image is used as the intensity prior, instead of sampling the intensities from the seeds. Default is False . sample ( idx , genparams = {}) Retrieve a single item from the dataset at the specified index. Parameters: idx ( int ) \u2013 The index of the item to retrieve. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow exactly the same structure and be of the same type as the returned generation parameters. Can be used to replicate the augmentations (power) used for the generation of a specific sample. Returns: Dictionaries with the generated data and the generation parameters. First dictionary contains the image , label and the name keys. The second dictionary contains the parameters used for the generation. Note The image is scaled to [0, 1] and oriented with the label to RAS and returned on the device specified in the generator initialization. __getitem__ ( idx ) Retrieve a single item from the dataset at the specified index. Parameters: idx ( int ) \u2013 The index of the item to retrieve. Returns: dict \u2013 Dictionary with the image , label and the name keys. image and label are torch.float32 monai.data.meta_tensor.MetaTensor and name is a string of a format sub_ses where sub is the subject name and ses is the session name. Note The image is scaled to [0, 1] and oriented to RAS and returned on the device specified in the generator initialization. sample_with_meta ( idx , genparams = {}) Retrieve a sample along with its generation parameters and store them in the same dictionary. Parameters: idx ( int ) \u2013 The index of the sample to retrieve. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow exactly the same structure and be of the same type as the returned generation parameters from the sample() method. Can be used to replicate the augmentations (power) used for the generation of a specific sample. Returns: dict \u2013 A dictionary with image , label , name and generation_params keys. Fixed Image Generation It is possible to generate synthetic images of the same 'augmentation' power as any given synthetic image. This is done by passing the genparams dictionary to the sample_with_meta (or sample ) method of the FetalSynthDataset class. The generation_params dictionary is a dictionary of the parameters used to generate the image. The method will then use these parameters to generate a new image with the same augmentation power as the original image. This genparams dictionary can be obtained, for example, from the dictionary returned by the FetalSynthDataset.sample_with_meta method. It then can be directly used to fix (some or all) generation parameters for the new image. See example below: # initialize the dataset class # see the Examples page for more details dataset = FetalSynthDataset ( ... ) # first sample a synthetic image from the dataset sample = dataset . sample_with_meta ( 0 ) # then we sample a synthetic image with the same augmentation power as the first image sample_copy = dataset . sample_with_meta ( 0 , genparams = sample [ \"generation_params\" ]) For example, generation parameters of the first image can be like this: { 'idx' : 0 , 'img_paths' : PosixPath ( '../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz' ), 'segm_paths' : PosixPath ( '../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz' ), 'seeds' : defaultdict ( dict , { 1 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}, 2 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}, 3 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}}), 'selected_seeds' : { 'mlabel2subclusters' : { 1 : 2 , 2 : 1 , 3 : 3 , 4 : 1 }}, 'seed_intensities' : { 'mus' : tensor ([ 109.6722 , 220.9658 , 100.9801 , 38.6364 , 125.5148 , 108.1950 , 216.1060 , 190.5462 , 55.3930 , 59.2667 , 72.0628 , 68.8775 , 76.5113 , 84.6639 , 90.0124 , 94.1701 , 67.0610 , 25.9465 , 31.5438 , 21.0375 , 192.4223 , 173.7434 , 139.9284 , 121.3904 , 145.4289 , 158.1318 , 157.4630 , 150.0894 , 183.9047 , 181.7129 , 114.8939 , 9.5253 , 29.0257 , 97.9543 , 122.0798 , 72.2969 , 26.3086 , 81.8050 , 67.7463 , 72.3737 , 129.8539 , 113.3900 , 141.8177 , 225.0000 , 35.3458 , 173.7635 , 29.5101 , 135.9482 , 188.2391 , 225.0000 ], device = 'cuda:0' ), 'sigmas' : tensor ([ 9.2432 , 23.1060 , 16.4965 , 6.4289 , 24.7862 , 23.7996 , 15.2424 , 20.2845 , 12.6833 , 6.9079 , 6.1214 , 22.1317 , 9.7907 , 5.5302 , 14.3288 , 11.1454 , 16.0453 , 20.9057 , 24.2358 , 13.4785 , 22.7258 , 11.2053 , 12.9420 , 13.4270 , 14.8660 , 22.4874 , 5.6251 , 9.8794 , 8.8749 , 19.0294 , 9.7164 , 6.2293 , 13.6376 , 11.7447 , 14.1414 , 6.4362 , 20.4575 , 14.6729 , 8.4719 , 14.2926 , 6.9458 , 11.5346 , 14.6113 , 6.6516 , 22.1767 , 8.3793 , 20.1699 , 6.3299 , 5.3340 , 21.8027 ], device = 'cuda:0' )}, 'deform_params' : { 'affine' : { 'rotations' : array ([ 0.0008224 , 0.03067143 , - 0.0151502 ]), 'shears' : array ([ - 0.01735838 , 0.00744726 , 0.00012507 ]), 'scalings' : array ([ 1.09345725 , 0.91695532 , 0.98194215 ])}, 'non_rigid' : { 'nonlin_scale' : array ([ 0.05686841 ]), 'nonlin_std' : 1.048839010036788 , 'size_F_small' : [ 15 , 15 , 15 ]}, 'flip' : False }, 'gamma_params' : { 'gamma' : 0.960299468352801 }, 'bf_params' : { 'bf_scale' : None , 'bf_std' : None , 'bf_size' : None }, 'resample_params' : { 'spacing' : array ([ 0.65685245 , 0.65685245 , 0.65685245 ])}, 'noise_params' : { 'noise_std' : None }, 'generation_time' : 0.5615839958190918 } If the key:value pair exists in the passed genparams dictionary, the sample method will use directly the value from the genparams dictionary. If the key:value pair does not exist in the genparams dictionary or it is None , sample method will generate the value randomly, using the corresponding class attributes. See how the keys bf_scale , bf_std , bf_size and noise_std have not been defined in the genparams dictionary above. This means that the sample method will generate these values randomly. The same could have been achieved by not passing them at all. {'idx': 0, 'img_paths': PosixPath('../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz'), 'segm_paths': PosixPath('../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz'), 'seeds': defaultdict(dict, {1: {1: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}, 2: {1: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}, 3: {1: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}}), 'selected_seeds': {'mlabel2subclusters': {1: 2, 2: 1, 3: 3, 4: 1}}, 'seed_intensities': {'mus': tensor([109.6722, 220.9658, 100.9801, 38.6364, 125.5148, 108.1950, 216.1060, 190.5462, 55.3930, 59.2667, 72.0628, 68.8775, 76.5113, 84.6639, 90.0124, 94.1701, 67.0610, 25.9465, 31.5438, 21.0375, 192.4223, 173.7434, 139.9284, 121.3904, 145.4289, 158.1318, 157.4630, 150.0894, 183.9047, 181.7129, 114.8939, 9.5253, 29.0257, 97.9543, 122.0798, 72.2969, 26.3086, 81.8050, 67.7463, 72.3737, 129.8539, 113.3900, 141.8177, 225.0000, 35.3458, 173.7635, 29.5101, 135.9482, 188.2391, 225.0000], device='cuda:0'), 'sigmas': tensor([ 9.2432, 23.1060, 16.4965, 6.4289, 24.7862, 23.7996, 15.2424, 20.2845, 12.6833, 6.9079, 6.1214, 22.1317, 9.7907, 5.5302, 14.3288, 11.1454, 16.0453, 20.9057, 24.2358, 13.4785, 22.7258, 11.2053, 12.9420, 13.4270, 14.8660, 22.4874, 5.6251, 9.8794, 8.8749, 19.0294, 9.7164, 6.2293, 13.6376, 11.7447, 14.1414, 6.4362, 20.4575, 14.6729, 8.4719, 14.2926, 6.9458, 11.5346, 14.6113, 6.6516, 22.1767, 8.3793, 20.1699, 6.3299, 5.3340, 21.8027], device='cuda:0')}, 'deform_params': {'affine': {'rotations': array([ 0.0008224 , 0.03067143, -0.0151502 ]), 'shears': array([-0.01735838, 0.00744726, 0.00012507]), 'scalings': array([1.09345725, 0.91695532, 0.98194215])}, 'non_rigid': {'nonlin_scale': array([0.05686841]), 'nonlin_std': 1.048839010036788, 'size_F_small': [15, 15, 15]}, 'flip': False}, 'gamma_params': {'gamma': 0.960299468352801}, 'bf_params': {'bf_scale': array([0.00797334]), 'bf_std': array([0.21896995]), 'bf_size': [2, 2, 2]}, 'resample_params': {'spacing': array([0.65685245, 0.65685245, 0.65685245])}, 'noise_params': {'noise_std': None}, 'generation_time': 0.6192283630371094} ``` Note If a specific parameter is passed in genparams it means that the probability of its application is 100%. The internal prob is not used as the parameter is fixed. If using custom values for the parameters, ensure that the values are within the range of the parameters defined in the class attributes (especially for the spatial deformation parameters, as the grid is pre-defined at class initialization). Furthermore, ensure that the device location and parameter type is consistent with the one in the returned generation_parameters dictionary.","title":"Datasets"},{"location":"datasets/#datasets","text":"Classes for loading and processing datasets. Note \ud83d\udcdd Device : All datasets return samples with tensors on the CPU (even when the synthetic data generation is done on the GPU). This is due to restriction on the GPU usage in the multiprocessing settings, where GPU memory cannot be easily shared between processes. \ud83d\udcdd Dataloader : When using torch.utils.data.DataLoader ensure that you pass multiprocessing_context=\"spawn\" argument to the dataloader object when using FetalSynthDataset to ensure that the spawned processes have access to the GPU.","title":"Datasets"},{"location":"datasets/#fetalsyngen.data.datasets.FetalDataset","text":"Abstract class defining a dataset for loading fetal data.","title":"FetalDataset"},{"location":"datasets/#fetalsyngen.data.datasets.FetalDataset.__init__","text":"Parameters: bids_path ( str ) \u2013 Path to the bids folder with the data. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used.","title":"__init__"},{"location":"datasets/#fetalsyngen.data.datasets.FetalTestDataset","text":"Bases: FetalDataset Dataset class for loading fetal images offline. Used to load test/validation data. Use the transforms argument to pass additional processing steps (scaling, resampling, cropping, etc.).","title":"FetalTestDataset"},{"location":"datasets/#fetalsyngen.data.datasets.FetalTestDataset.__init__","text":"Parameters: bids_path ( str ) \u2013 Path to the bids folder with the data. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used. transforms ( Compose | None , default: None ) \u2013 Compose object with the transformations to apply. Default is None, no transformations are applied. Note We highle recommend using the transforms arguments with at least the re-oriented transform to RAS and the intensity scaling to [0, 1] to ensure the data consistency. See inference.yaml for an example of the transforms configuration.","title":"__init__"},{"location":"datasets/#fetalsyngen.data.datasets.FetalTestDataset.__getitem__","text":"Returns: dict \u2013 Dictionary with the image , label and the name keys. image and label are torch.float32 monai.data.meta_tensor.MetaTensor instances with dimensions (1, H, W, D) and name is a string of a format sub_ses where sub is the subject name and ses is the session name.","title":"__getitem__"},{"location":"datasets/#fetalsyngen.data.datasets.FetalTestDataset.reverse_transform","text":"Reverse the transformations applied to the data. Parameters: data ( dict ) \u2013 Dictionary with the image and label keys, like the one returned by the __getitem__ method. Returns: dict \u2013 Dictionary with the image and label keys where the transformations are reversed.","title":"reverse_transform"},{"location":"datasets/#fetalsyngen.data.datasets.FetalSynthDataset","text":"Bases: FetalDataset Dataset class for generating/augmenting on-the-fly fetal images\"","title":"FetalSynthDataset"},{"location":"datasets/#fetalsyngen.data.datasets.FetalSynthDataset.__init__","text":"Parameters: bids_path ( str ) \u2013 Path to the bids-formatted folder with the data. seed_path ( str | None ) \u2013 Path to the folder with the seeds to use for intensity sampling. See scripts/seed_generation.py for details on the data formatting. If seed_path is None, the intensity sampling step is skipped and the output image intensities will be based on the input image. generator ( FetalSynthGen ) \u2013 a class object defining a generator to use. sub_list ( list [ str ] | None ) \u2013 List of the subjects to use. If None, all subjects are used. load_image ( bool , default: False ) \u2013 If True , the image is loaded and passed to the generator, where it can be used as the intensity prior instead of a random intensity sampling or spatially deformed with the same transformation field as segmentation and the syntehtic image. Default is False . image_as_intensity ( bool , default: False ) \u2013 If True , the image is used as the intensity prior, instead of sampling the intensities from the seeds. Default is False .","title":"__init__"},{"location":"datasets/#fetalsyngen.data.datasets.FetalSynthDataset.sample","text":"Retrieve a single item from the dataset at the specified index. Parameters: idx ( int ) \u2013 The index of the item to retrieve. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow exactly the same structure and be of the same type as the returned generation parameters. Can be used to replicate the augmentations (power) used for the generation of a specific sample. Returns: Dictionaries with the generated data and the generation parameters. First dictionary contains the image , label and the name keys. The second dictionary contains the parameters used for the generation. Note The image is scaled to [0, 1] and oriented with the label to RAS and returned on the device specified in the generator initialization.","title":"sample"},{"location":"datasets/#fetalsyngen.data.datasets.FetalSynthDataset.__getitem__","text":"Retrieve a single item from the dataset at the specified index. Parameters: idx ( int ) \u2013 The index of the item to retrieve. Returns: dict \u2013 Dictionary with the image , label and the name keys. image and label are torch.float32 monai.data.meta_tensor.MetaTensor and name is a string of a format sub_ses where sub is the subject name and ses is the session name. Note The image is scaled to [0, 1] and oriented to RAS and returned on the device specified in the generator initialization.","title":"__getitem__"},{"location":"datasets/#fetalsyngen.data.datasets.FetalSynthDataset.sample_with_meta","text":"Retrieve a sample along with its generation parameters and store them in the same dictionary. Parameters: idx ( int ) \u2013 The index of the sample to retrieve. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow exactly the same structure and be of the same type as the returned generation parameters from the sample() method. Can be used to replicate the augmentations (power) used for the generation of a specific sample. Returns: dict \u2013 A dictionary with image , label , name and generation_params keys.","title":"sample_with_meta"},{"location":"datasets/#fixed-image-generation","text":"It is possible to generate synthetic images of the same 'augmentation' power as any given synthetic image. This is done by passing the genparams dictionary to the sample_with_meta (or sample ) method of the FetalSynthDataset class. The generation_params dictionary is a dictionary of the parameters used to generate the image. The method will then use these parameters to generate a new image with the same augmentation power as the original image. This genparams dictionary can be obtained, for example, from the dictionary returned by the FetalSynthDataset.sample_with_meta method. It then can be directly used to fix (some or all) generation parameters for the new image. See example below: # initialize the dataset class # see the Examples page for more details dataset = FetalSynthDataset ( ... ) # first sample a synthetic image from the dataset sample = dataset . sample_with_meta ( 0 ) # then we sample a synthetic image with the same augmentation power as the first image sample_copy = dataset . sample_with_meta ( 0 , genparams = sample [ \"generation_params\" ]) For example, generation parameters of the first image can be like this: { 'idx' : 0 , 'img_paths' : PosixPath ( '../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz' ), 'segm_paths' : PosixPath ( '../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz' ), 'seeds' : defaultdict ( dict , { 1 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}, 2 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}, 3 : { 1 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz' ), 2 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz' ), 3 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz' ), 4 : PosixPath ( '../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz' )}}), 'selected_seeds' : { 'mlabel2subclusters' : { 1 : 2 , 2 : 1 , 3 : 3 , 4 : 1 }}, 'seed_intensities' : { 'mus' : tensor ([ 109.6722 , 220.9658 , 100.9801 , 38.6364 , 125.5148 , 108.1950 , 216.1060 , 190.5462 , 55.3930 , 59.2667 , 72.0628 , 68.8775 , 76.5113 , 84.6639 , 90.0124 , 94.1701 , 67.0610 , 25.9465 , 31.5438 , 21.0375 , 192.4223 , 173.7434 , 139.9284 , 121.3904 , 145.4289 , 158.1318 , 157.4630 , 150.0894 , 183.9047 , 181.7129 , 114.8939 , 9.5253 , 29.0257 , 97.9543 , 122.0798 , 72.2969 , 26.3086 , 81.8050 , 67.7463 , 72.3737 , 129.8539 , 113.3900 , 141.8177 , 225.0000 , 35.3458 , 173.7635 , 29.5101 , 135.9482 , 188.2391 , 225.0000 ], device = 'cuda:0' ), 'sigmas' : tensor ([ 9.2432 , 23.1060 , 16.4965 , 6.4289 , 24.7862 , 23.7996 , 15.2424 , 20.2845 , 12.6833 , 6.9079 , 6.1214 , 22.1317 , 9.7907 , 5.5302 , 14.3288 , 11.1454 , 16.0453 , 20.9057 , 24.2358 , 13.4785 , 22.7258 , 11.2053 , 12.9420 , 13.4270 , 14.8660 , 22.4874 , 5.6251 , 9.8794 , 8.8749 , 19.0294 , 9.7164 , 6.2293 , 13.6376 , 11.7447 , 14.1414 , 6.4362 , 20.4575 , 14.6729 , 8.4719 , 14.2926 , 6.9458 , 11.5346 , 14.6113 , 6.6516 , 22.1767 , 8.3793 , 20.1699 , 6.3299 , 5.3340 , 21.8027 ], device = 'cuda:0' )}, 'deform_params' : { 'affine' : { 'rotations' : array ([ 0.0008224 , 0.03067143 , - 0.0151502 ]), 'shears' : array ([ - 0.01735838 , 0.00744726 , 0.00012507 ]), 'scalings' : array ([ 1.09345725 , 0.91695532 , 0.98194215 ])}, 'non_rigid' : { 'nonlin_scale' : array ([ 0.05686841 ]), 'nonlin_std' : 1.048839010036788 , 'size_F_small' : [ 15 , 15 , 15 ]}, 'flip' : False }, 'gamma_params' : { 'gamma' : 0.960299468352801 }, 'bf_params' : { 'bf_scale' : None , 'bf_std' : None , 'bf_size' : None }, 'resample_params' : { 'spacing' : array ([ 0.65685245 , 0.65685245 , 0.65685245 ])}, 'noise_params' : { 'noise_std' : None }, 'generation_time' : 0.5615839958190918 } If the key:value pair exists in the passed genparams dictionary, the sample method will use directly the value from the genparams dictionary. If the key:value pair does not exist in the genparams dictionary or it is None , sample method will generate the value randomly, using the corresponding class attributes. See how the keys bf_scale , bf_std , bf_size and noise_std have not been defined in the genparams dictionary above. This means that the sample method will generate these values randomly. The same could have been achieved by not passing them at all. {'idx': 0, 'img_paths': PosixPath('../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz'), 'segm_paths': PosixPath('../data/sub-sta38/anat/sub-sta38_rec-irtk_T2w.nii.gz'), 'seeds': defaultdict(dict, {1: {1: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_1/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}, 2: {1: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_2/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}, 3: {1: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_1.nii.gz'), 2: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_2.nii.gz'), 3: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_3.nii.gz'), 4: PosixPath('../data/derivatives/seeds/subclasses_3/sub-sta38/anat/sub-sta38_rec-irtk_T2w_dseg_mlabel_4.nii.gz')}}), 'selected_seeds': {'mlabel2subclusters': {1: 2, 2: 1, 3: 3, 4: 1}}, 'seed_intensities': {'mus': tensor([109.6722, 220.9658, 100.9801, 38.6364, 125.5148, 108.1950, 216.1060, 190.5462, 55.3930, 59.2667, 72.0628, 68.8775, 76.5113, 84.6639, 90.0124, 94.1701, 67.0610, 25.9465, 31.5438, 21.0375, 192.4223, 173.7434, 139.9284, 121.3904, 145.4289, 158.1318, 157.4630, 150.0894, 183.9047, 181.7129, 114.8939, 9.5253, 29.0257, 97.9543, 122.0798, 72.2969, 26.3086, 81.8050, 67.7463, 72.3737, 129.8539, 113.3900, 141.8177, 225.0000, 35.3458, 173.7635, 29.5101, 135.9482, 188.2391, 225.0000], device='cuda:0'), 'sigmas': tensor([ 9.2432, 23.1060, 16.4965, 6.4289, 24.7862, 23.7996, 15.2424, 20.2845, 12.6833, 6.9079, 6.1214, 22.1317, 9.7907, 5.5302, 14.3288, 11.1454, 16.0453, 20.9057, 24.2358, 13.4785, 22.7258, 11.2053, 12.9420, 13.4270, 14.8660, 22.4874, 5.6251, 9.8794, 8.8749, 19.0294, 9.7164, 6.2293, 13.6376, 11.7447, 14.1414, 6.4362, 20.4575, 14.6729, 8.4719, 14.2926, 6.9458, 11.5346, 14.6113, 6.6516, 22.1767, 8.3793, 20.1699, 6.3299, 5.3340, 21.8027], device='cuda:0')}, 'deform_params': {'affine': {'rotations': array([ 0.0008224 , 0.03067143, -0.0151502 ]), 'shears': array([-0.01735838, 0.00744726, 0.00012507]), 'scalings': array([1.09345725, 0.91695532, 0.98194215])}, 'non_rigid': {'nonlin_scale': array([0.05686841]), 'nonlin_std': 1.048839010036788, 'size_F_small': [15, 15, 15]}, 'flip': False}, 'gamma_params': {'gamma': 0.960299468352801}, 'bf_params': {'bf_scale': array([0.00797334]), 'bf_std': array([0.21896995]), 'bf_size': [2, 2, 2]}, 'resample_params': {'spacing': array([0.65685245, 0.65685245, 0.65685245])}, 'noise_params': {'noise_std': None}, 'generation_time': 0.6192283630371094} ``` Note If a specific parameter is passed in genparams it means that the probability of its application is 100%. The internal prob is not used as the parameter is fixed. If using custom values for the parameters, ensure that the values are within the range of the parameters defined in the class attributes (especially for the spatial deformation parameters, as the grid is pre-defined at class initialization). Furthermore, ensure that the device location and parameter type is consistent with the one in the returned generation_parameters dictionary.","title":"Fixed Image Generation"},{"location":"examples/","text":"Examples After installing the package, you can directly use the generator and datasets in your project. See the following examples for guidance on how to instantiate the generator and datasets. Recommended: Using Configuration Files For reproducibility and greater flexibility, we recommend using the configuration files provided in the package. These files define the parameters for the generator and datasets, allowing for quick and easy setup with hydra . Steps to Use Configuration Files Copy the configuration files (entire configs/dataset folder) to your project root directory into configs/dataset . Use the following methods to instantiate the generator and dataset classes: For examples below, set up cfg_path = \"configs/dataset\" as the path to the configuration files and cfg_name as the name of the configuration file you want to use ( cfg_name='synth_train' for example for the synthetic training dataset). See the Configs page for detailed information on configuration files and available generation modes. Using the Imperative API import hydra with hydra . initialize ( config_path = cfg_path , version_base = \"1.2\" ): cfg = hydra . compose ( config_name = cfg_name ) print ( f \"Composed config: { cfg } \" ) dataset = hydra . utils . instantiate ( cfg ) Using the Declarative API import hydra from omegaconf import DictConfig @hydra . main ( config_path = cfg_path , config_name = cfg_name ) def my_app ( cfg : DictConfig ) -> None : print ( cfg ) Note Ensure that the bids and seeds paths in the configuration files are updated to the absolute paths for your data. Using Direct Instantiation You can manually instantiate required classes from the FetalSynthGen in your project as needed. For example, to instantiate the FetalSynthDataset class and generator components follow the example below: # Import necessary classes from fetalsyngen.data.datasets import FetalSynthDataset from fetalsyngen.generator.model import FetalSynthGen from fetalsyngen.generator.augmentation.synthseg import ( RandBiasField , RandGamma , RandNoise , RandResample , ) from fetalsyngen.generator.deformation.affine_nonrigid import SpatialDeformation from fetalsyngen.generator.intensity.rand_gmm import ImageFromSeeds # Instantiate the generator components intensity_generator = ImageFromSeeds ( min_subclusters = 1 , max_subclusters = 3 , seed_labels = [ 1 , 2 , 3 , 4 , 5 ], generation_classes = [ 1 , 2 , 3 , 4 , 5 ], meta_labels = 4 , ) spatial_deform = SpatialDeformation ( max_rotation = 10 , max_shear = 1 , max_scaling = 1 , size = ( 256 , 256 , 256 ), nonlinear_transform = 1 , nonlin_scale_min = 1 , nonlin_scale_max = 1 , nonlin_std_max = 1 , flip_prb = 1 , device = \"cuda\" , ) resampler = RandResample ( prob = 0.5 , max_resolution = 1.5 , min_resolution = 0.5 ) bias_field = RandBiasField ( prob = 0.5 , scale_min = 0.5 , scale_max = 1.5 , std_min = 0.5 , std_max = 1.5 ) noise = RandNoise ( prob = 0.5 , std_min = 0.5 , std_max = 1.5 ) gamma = RandGamma ( prob = 0.5 , gamma_std = 0.5 ) # Instantiate the generator generator = FetalSynthGen ( shape = ( 256 , 256 , 256 ), resolution = ( 0.5 , 0.5 , 0.5 ), device = \"cuda\" , intensity_generator = intensity_generator , spatial_deform = spatial_deform , resampler = resampler , bias_field = bias_field , noise = noise , gamma = gamma , ) # Instantiate the dataset dataset = FetalSynthDataset ( bids_path = \"./../../data\" , generator = generator , seed_path = \"./../../data/derivatives/seeds\" , sub_list = None , ) Additional Resources For more examples of generator instantiation with hydra , see the Generator Instantiation notebook.","title":"Examples"},{"location":"examples/#examples","text":"After installing the package, you can directly use the generator and datasets in your project. See the following examples for guidance on how to instantiate the generator and datasets.","title":"Examples"},{"location":"examples/#recommended-using-configuration-files","text":"For reproducibility and greater flexibility, we recommend using the configuration files provided in the package. These files define the parameters for the generator and datasets, allowing for quick and easy setup with hydra .","title":"Recommended: Using Configuration Files"},{"location":"examples/#steps-to-use-configuration-files","text":"Copy the configuration files (entire configs/dataset folder) to your project root directory into configs/dataset . Use the following methods to instantiate the generator and dataset classes: For examples below, set up cfg_path = \"configs/dataset\" as the path to the configuration files and cfg_name as the name of the configuration file you want to use ( cfg_name='synth_train' for example for the synthetic training dataset). See the Configs page for detailed information on configuration files and available generation modes. Using the Imperative API import hydra with hydra . initialize ( config_path = cfg_path , version_base = \"1.2\" ): cfg = hydra . compose ( config_name = cfg_name ) print ( f \"Composed config: { cfg } \" ) dataset = hydra . utils . instantiate ( cfg ) Using the Declarative API import hydra from omegaconf import DictConfig @hydra . main ( config_path = cfg_path , config_name = cfg_name ) def my_app ( cfg : DictConfig ) -> None : print ( cfg ) Note Ensure that the bids and seeds paths in the configuration files are updated to the absolute paths for your data.","title":"Steps to Use Configuration Files"},{"location":"examples/#using-direct-instantiation","text":"You can manually instantiate required classes from the FetalSynthGen in your project as needed. For example, to instantiate the FetalSynthDataset class and generator components follow the example below: # Import necessary classes from fetalsyngen.data.datasets import FetalSynthDataset from fetalsyngen.generator.model import FetalSynthGen from fetalsyngen.generator.augmentation.synthseg import ( RandBiasField , RandGamma , RandNoise , RandResample , ) from fetalsyngen.generator.deformation.affine_nonrigid import SpatialDeformation from fetalsyngen.generator.intensity.rand_gmm import ImageFromSeeds # Instantiate the generator components intensity_generator = ImageFromSeeds ( min_subclusters = 1 , max_subclusters = 3 , seed_labels = [ 1 , 2 , 3 , 4 , 5 ], generation_classes = [ 1 , 2 , 3 , 4 , 5 ], meta_labels = 4 , ) spatial_deform = SpatialDeformation ( max_rotation = 10 , max_shear = 1 , max_scaling = 1 , size = ( 256 , 256 , 256 ), nonlinear_transform = 1 , nonlin_scale_min = 1 , nonlin_scale_max = 1 , nonlin_std_max = 1 , flip_prb = 1 , device = \"cuda\" , ) resampler = RandResample ( prob = 0.5 , max_resolution = 1.5 , min_resolution = 0.5 ) bias_field = RandBiasField ( prob = 0.5 , scale_min = 0.5 , scale_max = 1.5 , std_min = 0.5 , std_max = 1.5 ) noise = RandNoise ( prob = 0.5 , std_min = 0.5 , std_max = 1.5 ) gamma = RandGamma ( prob = 0.5 , gamma_std = 0.5 ) # Instantiate the generator generator = FetalSynthGen ( shape = ( 256 , 256 , 256 ), resolution = ( 0.5 , 0.5 , 0.5 ), device = \"cuda\" , intensity_generator = intensity_generator , spatial_deform = spatial_deform , resampler = resampler , bias_field = bias_field , noise = noise , gamma = gamma , ) # Instantiate the dataset dataset = FetalSynthDataset ( bids_path = \"./../../data\" , generator = generator , seed_path = \"./../../data/derivatives/seeds\" , sub_list = None , )","title":"Using Direct Instantiation"},{"location":"examples/#additional-resources","text":"For more examples of generator instantiation with hydra , see the Generator Instantiation notebook.","title":"Additional Resources"},{"location":"generation/","text":"Generation API FetalSynthGen __init__ ( shape , resolution , device , intensity_generator , spatial_deform , resampler , bias_field , noise , gamma ) Initialize the model with the given parameters. Parameters: shape ( Iterable [ int ] ) \u2013 Shape of the output image. resolution ( Iterable [ float ] ) \u2013 Resolution of the output image. device ( str ) \u2013 Device to use for computation. intensity_generator ( ImageFromSeeds ) \u2013 Intensity generator. spatial_deform ( SpatialDeformation ) \u2013 Spatial deformation generator. resampler ( RandResample ) \u2013 Resampler. bias_field ( RandBiasField ) \u2013 Bias field generator. noise ( RandNoise ) \u2013 Noise generator. gamma ( RandGamma ) \u2013 Gamma correction generator. sample ( image , segmentation , seeds , genparams = {}) Generate a synthetic image from the input data. Supports both random generation and from a fixed genparams dictionary. Parameters: image \u2013 Image to use as intensity prior. segmentation \u2013 Segmentation to use as spatial prior. seeds ( Tensor | None ) \u2013 Seeds to use for intensity generation. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow the structure and be of the same type as the returned generation parameters. Returns: tuple [ Tensor , Tensor , Tensor , dict ] \u2013 The synthetic image, the segmentation, the original image, and the generation parameters. ImageFromSeeds __init__ ( min_subclusters , max_subclusters , seed_labels , generation_classes , meta_labels = 4 ) Parameters: min_subclusters ( int ) \u2013 Minimum number of subclusters to use. max_subclusters ( int ) \u2013 Maximum number of subclusters to use. seed_labels ( Iterable [ int ] ) \u2013 Iterable with all possible labels that can occur in the loaded seeds. Should be a unique set of integers starting from [0, ...]. 0 is reserved for the background, that will not have any intensity generated. generation_classes ( Iterable [ int ] ) \u2013 Classes to use for generation. Seeds with the same generation calss will be generated with the same GMM. Should be the same length as seed_labels. meta_labels ( int , default: 4 ) \u2013 Number of meta-labels used. Defaults to 4. load_seeds ( seeds , mlabel2subclusters = None , genparams = {}) Generate an intensity image from seeds. If seed_mapping is provided, it is used to select the number of subclusters to use for each meta label. Otherwise, the number of subclusters is randomly selected from a uniform discrete distribution between min_subclusters and max_subclusters (both inclusive). Args: seeds: Dictionary with the mapping `subcluster_number: {meta_label: seed_path}`. mlabel2subclusters: Mapping to use when defining how many subclusters to use for each meta-label. Defaults to None. genparams: Dictionary with generation parameters. Defaults to {}. Should contain the key \"mlabel2subclusters\" if the mapping is to be fixed. Returns: Tensor \u2013 torch.Tensor: Intensity image with the same shape as the seeds. Tensor dimensions are (H, W, D) . Values inside the tensor correspond to the subclusters, and are grouped by meta-label. 1-19: CSF, 20-29: GM, 30-39: WM, 40-49: Extra-cerebral . sample_intensities ( seeds , device , genparams = {}) Sample the intensities from the seeds. Parameters: seeds ( Tensor ) \u2013 Tensor with the seeds. device ( str ) \u2013 Device to use. Should be \"cuda\" or \"cpu\". genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Defaults to {}. Should contain the keys \"mus\" and \"sigmas\" if the GMM parameters are to be fixed. Returns: Tensor \u2013 torch.Tensor: Tensor with the intensities. SpatialDeformation Class defining the spatial deformation of the image. Combines both random affine and nonlinear transformations to deform the image. __init__ ( max_rotation , max_shear , max_scaling , size , prob , nonlinear_transform , nonlin_scale_min , nonlin_scale_max , nonlin_std_max , flip_prb , device ) Initialize the spatial deformation. Parameters: max_rotation ( float ) \u2013 Maximum rotation in degrees. max_shear ( float ) \u2013 Maximum shear. max_scaling ( float ) \u2013 Maximum scaling. size ( Iterable [ int ] ) \u2013 Size of the output image. prob ( float ) \u2013 Probability of applying the deformation. nonlinear_transform ( bool ) \u2013 Whether to apply nonlinear transformation. nonlin_scale_min ( float ) \u2013 Minimum scale for the nonlinear transformation. nonlin_scale_max ( float ) \u2013 Maximum scale for the nonlinear transformation. nonlin_std_max ( float ) \u2013 Maximum standard deviation for the nonlinear transformation. flip_prb ( float ) \u2013 Probability of flipping the image. device ( str ) \u2013 Device to use for computation. Either \"cuda\" or \"cpu\". deform ( image , segmentation , output , genparams = {}) Deform the image, segmentation and output. Parameters: image ( Tensor ) \u2013 Image to deform. segmentation ( Tensor ) \u2013 Segmentation to deform. output ( Tensor ) \u2013 Output to deform. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Defaults to {}. Should contain the keys \"affine\" and \"non_rigid\" if the parameters are fixed. Affine parameters should contain the keys \"rotations\", \"shears\" and \"scalings\". Non-rigid parameters should contain the keys \"nonlin_scale\", \"nonlin_std\" and \"size_F_small\". Returns: \u2013 tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]: Deformed image, segmentation, output and deformation parameters. RandResample Bases: RandTransform Resample the input image to a random resolution sampled uniformly between min_resolution and max_resolution with a probability of prob . If the resolution is smaller than the input resolution, no resampling is performed. __init__ ( prob , min_resolution , max_resolution ) Initialize the augmentation parameters. Parameters: prob ( float ) \u2013 Probability of applying the augmentation. min_resolution ( float ) \u2013 Minimum resolution for the augmentation (in mm). max_resolution ( float ) \u2013 Maximum resolution for the augmentation. __call__ ( output , input_resolution , device , genparams = {}) Apply the resampling to the input image. Parameters: output ( Tensor ) \u2013 Input image to resample. input_resolution ( array ) \u2013 Resolution of the input image. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"spacing\" if the spacing is fixed. Returns: \u2013 torch.Tensor: Resampled image. RandBiasField Bases: RandTransform Add a random bias field to the input image with a probability of prob . __init__ ( prob , scale_min , scale_max , std_min , std_max ) Parameters: prob ( float ) \u2013 Probability of applying the augmentation. scale_min ( float ) \u2013 Minimum scale of the bias field. scale_max ( float ) \u2013 Maximum scale of the bias field. std_min ( float ) \u2013 Minimum standard deviation of the bias field. std_max ( float ) \u2013 Maximum standard deviation of the bias. __call__ ( output , device , genparams = {}) Apply the bias field to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the bias field. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the keys \"bf_scale\", \"bf_std\" and \"bf_size\" if the bias field parameters are fixed. Returns: \u2013 torch.Tensor: Image with the bias field applied. RandNoise Bases: RandTransform Add random Gaussian noise to the input image with a probability of prob . __init__ ( prob , std_min , std_max ) The image scale is 0-255 so the noise is added in the same scale. Args: prob: Probability of applying the augmentation. std_min: Minimum standard deviation of the noise. std_max: Maximum standard deviation of the noise __call__ ( output , device , genparams = {}) Apply the noise to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the noise. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"noise_std\" if the noise standard deviation is fixed. Returns: \u2013 torch.Tensor: Image with the noise applied. RandGamma Bases: RandTransform Apply gamma correction to the input image with a probability of prob . __init__ ( prob , gamma_std ) Parameters: prob ( float ) \u2013 Probability of applying the augmentation. gamma_std ( float ) \u2013 Standard deviation of the gamma correction. __call__ ( output , device , genparams = {}) Apply the gamma correction to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the gamma correction. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"gamma\" if the gamma correction is fixed. Returns: \u2013 torch.Tensor: Image with the gamma correction applied. Fixed Image Generation","title":"Generation"},{"location":"generation/#generation","text":"","title":"Generation"},{"location":"generation/#api","text":"","title":"API"},{"location":"generation/#fetalsyngen.generator.model.FetalSynthGen","text":"","title":"FetalSynthGen"},{"location":"generation/#fetalsyngen.generator.model.FetalSynthGen.__init__","text":"Initialize the model with the given parameters. Parameters: shape ( Iterable [ int ] ) \u2013 Shape of the output image. resolution ( Iterable [ float ] ) \u2013 Resolution of the output image. device ( str ) \u2013 Device to use for computation. intensity_generator ( ImageFromSeeds ) \u2013 Intensity generator. spatial_deform ( SpatialDeformation ) \u2013 Spatial deformation generator. resampler ( RandResample ) \u2013 Resampler. bias_field ( RandBiasField ) \u2013 Bias field generator. noise ( RandNoise ) \u2013 Noise generator. gamma ( RandGamma ) \u2013 Gamma correction generator.","title":"__init__"},{"location":"generation/#fetalsyngen.generator.model.FetalSynthGen.sample","text":"Generate a synthetic image from the input data. Supports both random generation and from a fixed genparams dictionary. Parameters: image \u2013 Image to use as intensity prior. segmentation \u2013 Segmentation to use as spatial prior. seeds ( Tensor | None ) \u2013 Seeds to use for intensity generation. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Used for fixed generation. Should follow the structure and be of the same type as the returned generation parameters. Returns: tuple [ Tensor , Tensor , Tensor , dict ] \u2013 The synthetic image, the segmentation, the original image, and the generation parameters.","title":"sample"},{"location":"generation/#fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds","text":"","title":"ImageFromSeeds"},{"location":"generation/#fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds.__init__","text":"Parameters: min_subclusters ( int ) \u2013 Minimum number of subclusters to use. max_subclusters ( int ) \u2013 Maximum number of subclusters to use. seed_labels ( Iterable [ int ] ) \u2013 Iterable with all possible labels that can occur in the loaded seeds. Should be a unique set of integers starting from [0, ...]. 0 is reserved for the background, that will not have any intensity generated. generation_classes ( Iterable [ int ] ) \u2013 Classes to use for generation. Seeds with the same generation calss will be generated with the same GMM. Should be the same length as seed_labels. meta_labels ( int , default: 4 ) \u2013 Number of meta-labels used. Defaults to 4.","title":"__init__"},{"location":"generation/#fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds.load_seeds","text":"Generate an intensity image from seeds. If seed_mapping is provided, it is used to select the number of subclusters to use for each meta label. Otherwise, the number of subclusters is randomly selected from a uniform discrete distribution between min_subclusters and max_subclusters (both inclusive). Args: seeds: Dictionary with the mapping `subcluster_number: {meta_label: seed_path}`. mlabel2subclusters: Mapping to use when defining how many subclusters to use for each meta-label. Defaults to None. genparams: Dictionary with generation parameters. Defaults to {}. Should contain the key \"mlabel2subclusters\" if the mapping is to be fixed. Returns: Tensor \u2013 torch.Tensor: Intensity image with the same shape as the seeds. Tensor dimensions are (H, W, D) . Values inside the tensor correspond to the subclusters, and are grouped by meta-label. 1-19: CSF, 20-29: GM, 30-39: WM, 40-49: Extra-cerebral .","title":"load_seeds"},{"location":"generation/#fetalsyngen.generator.intensity.rand_gmm.ImageFromSeeds.sample_intensities","text":"Sample the intensities from the seeds. Parameters: seeds ( Tensor ) \u2013 Tensor with the seeds. device ( str ) \u2013 Device to use. Should be \"cuda\" or \"cpu\". genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Defaults to {}. Should contain the keys \"mus\" and \"sigmas\" if the GMM parameters are to be fixed. Returns: Tensor \u2013 torch.Tensor: Tensor with the intensities.","title":"sample_intensities"},{"location":"generation/#fetalsyngen.generator.deformation.affine_nonrigid.SpatialDeformation","text":"Class defining the spatial deformation of the image. Combines both random affine and nonlinear transformations to deform the image.","title":"SpatialDeformation"},{"location":"generation/#fetalsyngen.generator.deformation.affine_nonrigid.SpatialDeformation.__init__","text":"Initialize the spatial deformation. Parameters: max_rotation ( float ) \u2013 Maximum rotation in degrees. max_shear ( float ) \u2013 Maximum shear. max_scaling ( float ) \u2013 Maximum scaling. size ( Iterable [ int ] ) \u2013 Size of the output image. prob ( float ) \u2013 Probability of applying the deformation. nonlinear_transform ( bool ) \u2013 Whether to apply nonlinear transformation. nonlin_scale_min ( float ) \u2013 Minimum scale for the nonlinear transformation. nonlin_scale_max ( float ) \u2013 Maximum scale for the nonlinear transformation. nonlin_std_max ( float ) \u2013 Maximum standard deviation for the nonlinear transformation. flip_prb ( float ) \u2013 Probability of flipping the image. device ( str ) \u2013 Device to use for computation. Either \"cuda\" or \"cpu\".","title":"__init__"},{"location":"generation/#fetalsyngen.generator.deformation.affine_nonrigid.SpatialDeformation.deform","text":"Deform the image, segmentation and output. Parameters: image ( Tensor ) \u2013 Image to deform. segmentation ( Tensor ) \u2013 Segmentation to deform. output ( Tensor ) \u2013 Output to deform. genparams ( dict , default: {} ) \u2013 Dictionary with generation parameters. Defaults to {}. Should contain the keys \"affine\" and \"non_rigid\" if the parameters are fixed. Affine parameters should contain the keys \"rotations\", \"shears\" and \"scalings\". Non-rigid parameters should contain the keys \"nonlin_scale\", \"nonlin_std\" and \"size_F_small\". Returns: \u2013 tuple[torch.Tensor, torch.Tensor, torch.Tensor, dict]: Deformed image, segmentation, output and deformation parameters.","title":"deform"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandResample","text":"Bases: RandTransform Resample the input image to a random resolution sampled uniformly between min_resolution and max_resolution with a probability of prob . If the resolution is smaller than the input resolution, no resampling is performed.","title":"RandResample"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandResample.__init__","text":"Initialize the augmentation parameters. Parameters: prob ( float ) \u2013 Probability of applying the augmentation. min_resolution ( float ) \u2013 Minimum resolution for the augmentation (in mm). max_resolution ( float ) \u2013 Maximum resolution for the augmentation.","title":"__init__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandResample.__call__","text":"Apply the resampling to the input image. Parameters: output ( Tensor ) \u2013 Input image to resample. input_resolution ( array ) \u2013 Resolution of the input image. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"spacing\" if the spacing is fixed. Returns: \u2013 torch.Tensor: Resampled image.","title":"__call__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandBiasField","text":"Bases: RandTransform Add a random bias field to the input image with a probability of prob .","title":"RandBiasField"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandBiasField.__init__","text":"Parameters: prob ( float ) \u2013 Probability of applying the augmentation. scale_min ( float ) \u2013 Minimum scale of the bias field. scale_max ( float ) \u2013 Maximum scale of the bias field. std_min ( float ) \u2013 Minimum standard deviation of the bias field. std_max ( float ) \u2013 Maximum standard deviation of the bias.","title":"__init__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandBiasField.__call__","text":"Apply the bias field to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the bias field. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the keys \"bf_scale\", \"bf_std\" and \"bf_size\" if the bias field parameters are fixed. Returns: \u2013 torch.Tensor: Image with the bias field applied.","title":"__call__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandNoise","text":"Bases: RandTransform Add random Gaussian noise to the input image with a probability of prob .","title":"RandNoise"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandNoise.__init__","text":"The image scale is 0-255 so the noise is added in the same scale. Args: prob: Probability of applying the augmentation. std_min: Minimum standard deviation of the noise. std_max: Maximum standard deviation of the noise","title":"__init__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandNoise.__call__","text":"Apply the noise to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the noise. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"noise_std\" if the noise standard deviation is fixed. Returns: \u2013 torch.Tensor: Image with the noise applied.","title":"__call__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandGamma","text":"Bases: RandTransform Apply gamma correction to the input image with a probability of prob .","title":"RandGamma"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandGamma.__init__","text":"Parameters: prob ( float ) \u2013 Probability of applying the augmentation. gamma_std ( float ) \u2013 Standard deviation of the gamma correction.","title":"__init__"},{"location":"generation/#fetalsyngen.generator.augmentation.synthseg.RandGamma.__call__","text":"Apply the gamma correction to the input image. Parameters: output ( Tensor ) \u2013 Input image to apply the gamma correction. device ( str ) \u2013 Device to use for computation. genparams ( dict , default: {} ) \u2013 Generation parameters. Default: {}. Should contain the key \"gamma\" if the gamma correction is fixed. Returns: \u2013 torch.Tensor: Image with the gamma correction applied.","title":"__call__"},{"location":"generation/#fixed-image-generation","text":"","title":"Fixed Image Generation"},{"location":"seed_generation/","text":"Seed Generation Introduction Seed generation is the first step in creating synthetic fetal brain MRI images with FetalSynthGen. It addresses the limited number of segmentation classes in fetal brain MRI. It allows the simulation of finer variations in tissue data. It reduces reliance on artificial contrast between segmentation labels and instead focuses on simulating anatomical variability within tissue types, helping to prevent models from learning label-specific contrast boundaries that may not exist in real images, which can be a problem with super-resolution MRI. How is it performed? First, original segmentation labels are merged into four meta-labels : cerebrospinal fluid (CSF), white matter (WM), gray matter (GM), and non-brain tissue (skull and surrounding tissue). Then, the Expectation-Maximisation (EM) algorithm is used for intensity clustering within each meta-label. This process divides each meta-label into a random number of subclasses , from one to four. These subclasses become the basis for generating synthetic images. Later in the generation pipeline, a Gaussian Mixture Model (GMM) is sampled for each subclass, and is used to sample intensities for voxels inside of it. This process ensures the synthetic images better reflect the heterogeneous nature of fetal brain tissue and the variability seen in real MRI data. See figure below for an example of seed generation. Usage The script fetalsyngen/scripts/generate_seeds.py is used to generate seeds for the FetalSynthGen pipeline. generate_seeds.py [-h] --bids_path BIDS_PATH --out_path OUT_PATH [--max_subclasses MAX_SUBCLASSES] --annotation {feta,dhcp} options: -h, --help show this help message and exit --bids_path BIDS_PATH Path to BIDS folder with the segmentations and images for seeds generation --out_path OUT_PATH Path to save the seeds --max_subclasses MAX_SUBCLASSES How many subclasses to simulate for each tissue type (meta-label) --annotation {feta,dhcp} Annotation type. Should be either 'feta' or 'dhcp' Example: python generate_seeds.py --bids_path /path/to/bids --out_path /path/to/out --max_subclasses 10 --annotation feta Note The --annotation flag specifies the type of segmentation labels to use. The feta option uses the FeTA Challenge labels, while the dhcp option uses the Developing Human Connectome Project (dHCP) labels as they have different segmentation classes. Output Format The output seeds are saved as int8 NIfTI files, with the same dimensions as the input images to speed up the seed loading process during generation. The output folder structure is as follows: \u251c\u2500\u2500 derivatives \u2502 \u251c\u2500\u2500 seeds \u2502 \u2502 \u2514\u2500\u2500 subclasses_ { 1 - max_subclasses } \u2502 \u2502 \u2514\u2500\u2500 sub - sta30 \u2502 \u2502 \u2514\u2500\u2500 anat \u2502 \u2502 \u2514\u2500\u2500 sub - sta30_rec - irtk_T2w_dseg_mlabel_ { 1 - 4 } . nii . gz \u2514\u2500\u2500 sub - sta30 \u2514\u2500\u2500 anat \u251c\u2500\u2500 sub - sta30_rec - irtk_T2w_dseg . nii . gz \u2514\u2500\u2500 sub - sta30_rec - irtk_T2w . nii . gz","title":"Seed Generation"},{"location":"seed_generation/#seed-generation","text":"","title":"Seed Generation"},{"location":"seed_generation/#introduction","text":"Seed generation is the first step in creating synthetic fetal brain MRI images with FetalSynthGen. It addresses the limited number of segmentation classes in fetal brain MRI. It allows the simulation of finer variations in tissue data. It reduces reliance on artificial contrast between segmentation labels and instead focuses on simulating anatomical variability within tissue types, helping to prevent models from learning label-specific contrast boundaries that may not exist in real images, which can be a problem with super-resolution MRI. How is it performed? First, original segmentation labels are merged into four meta-labels : cerebrospinal fluid (CSF), white matter (WM), gray matter (GM), and non-brain tissue (skull and surrounding tissue). Then, the Expectation-Maximisation (EM) algorithm is used for intensity clustering within each meta-label. This process divides each meta-label into a random number of subclasses , from one to four. These subclasses become the basis for generating synthetic images. Later in the generation pipeline, a Gaussian Mixture Model (GMM) is sampled for each subclass, and is used to sample intensities for voxels inside of it. This process ensures the synthetic images better reflect the heterogeneous nature of fetal brain tissue and the variability seen in real MRI data. See figure below for an example of seed generation.","title":"Introduction"},{"location":"seed_generation/#usage","text":"The script fetalsyngen/scripts/generate_seeds.py is used to generate seeds for the FetalSynthGen pipeline. generate_seeds.py [-h] --bids_path BIDS_PATH --out_path OUT_PATH [--max_subclasses MAX_SUBCLASSES] --annotation {feta,dhcp} options: -h, --help show this help message and exit --bids_path BIDS_PATH Path to BIDS folder with the segmentations and images for seeds generation --out_path OUT_PATH Path to save the seeds --max_subclasses MAX_SUBCLASSES How many subclasses to simulate for each tissue type (meta-label) --annotation {feta,dhcp} Annotation type. Should be either 'feta' or 'dhcp' Example: python generate_seeds.py --bids_path /path/to/bids --out_path /path/to/out --max_subclasses 10 --annotation feta Note The --annotation flag specifies the type of segmentation labels to use. The feta option uses the FeTA Challenge labels, while the dhcp option uses the Developing Human Connectome Project (dHCP) labels as they have different segmentation classes.","title":"Usage"},{"location":"seed_generation/#output-format","text":"The output seeds are saved as int8 NIfTI files, with the same dimensions as the input images to speed up the seed loading process during generation. The output folder structure is as follows: \u251c\u2500\u2500 derivatives \u2502 \u251c\u2500\u2500 seeds \u2502 \u2502 \u2514\u2500\u2500 subclasses_ { 1 - max_subclasses } \u2502 \u2502 \u2514\u2500\u2500 sub - sta30 \u2502 \u2502 \u2514\u2500\u2500 anat \u2502 \u2502 \u2514\u2500\u2500 sub - sta30_rec - irtk_T2w_dseg_mlabel_ { 1 - 4 } . nii . gz \u2514\u2500\u2500 sub - sta30 \u2514\u2500\u2500 anat \u251c\u2500\u2500 sub - sta30_rec - irtk_T2w_dseg . nii . gz \u2514\u2500\u2500 sub - sta30_rec - irtk_T2w . nii . gz","title":"Output Format"},{"location":"usage/","text":"How to use the generator? Follow these steps to integrate and use the generator in your project: 1. Install the Package Refer to the Installation page for detailed instructions on how to install the package. 2. Prepare the Dataset Ensure your dataset is formatted according to the BIDS format . Your dataset must include the following files: T2w image : Files should have the naming pattern *_T2w.nii.gz . Segmentation mask : Files should have the naming pattern *_dseg.nii.gz . Seeds : Seeds must be generated from a BIDS-formatted directory using the fetalsyngen/scripts/generate_seeds.py script. For additional details on seed generation, refer to the Seed Generation page. 3. Copy Dataset Configurations We provide a variety of ready-to-use configurations for different tasks. These configuration files are stored in the fetalsyngen/configs/dataset folder and are further detailed in the Configs page. Each configuration is a .yaml file that contains the parameters for the generation pipeline. You can modify these configurations to suit the specific requirements of your project. 4. Run the Generator We offer several torch.Dataset classes for loading synthetic and real datasets: fetalsyngen.data.datasets.FetalTestDataset : Loads real images and segmentations. Used for testing and validation on real data. fetalsyngen.data.datasets.FetalSynthDataset : Can be used to either to create synthetic images and segmentation on the fly or apply the same transformations used in generation of synthetic data to real images and segmentations. For more details on these datasets, see the Datasets page. Note \ud83d\udcdd Configs : Use the local copy of the config files from your repository to instantiate the generator/dataset classes. \ud83d\udcdd Paths : When using the dataset classes, ensure that the paths in your local configuration files are updated to correctly reference your dataset and seed files.","title":"How to use the generator?"},{"location":"usage/#how-to-use-the-generator","text":"Follow these steps to integrate and use the generator in your project:","title":"How to use the generator?"},{"location":"usage/#1-install-the-package","text":"Refer to the Installation page for detailed instructions on how to install the package.","title":"1. Install the Package"},{"location":"usage/#2-prepare-the-dataset","text":"Ensure your dataset is formatted according to the BIDS format . Your dataset must include the following files: T2w image : Files should have the naming pattern *_T2w.nii.gz . Segmentation mask : Files should have the naming pattern *_dseg.nii.gz . Seeds : Seeds must be generated from a BIDS-formatted directory using the fetalsyngen/scripts/generate_seeds.py script. For additional details on seed generation, refer to the Seed Generation page.","title":"2. Prepare the Dataset"},{"location":"usage/#3-copy-dataset-configurations","text":"We provide a variety of ready-to-use configurations for different tasks. These configuration files are stored in the fetalsyngen/configs/dataset folder and are further detailed in the Configs page. Each configuration is a .yaml file that contains the parameters for the generation pipeline. You can modify these configurations to suit the specific requirements of your project.","title":"3. Copy Dataset Configurations"},{"location":"usage/#4-run-the-generator","text":"We offer several torch.Dataset classes for loading synthetic and real datasets: fetalsyngen.data.datasets.FetalTestDataset : Loads real images and segmentations. Used for testing and validation on real data. fetalsyngen.data.datasets.FetalSynthDataset : Can be used to either to create synthetic images and segmentation on the fly or apply the same transformations used in generation of synthetic data to real images and segmentations. For more details on these datasets, see the Datasets page. Note \ud83d\udcdd Configs : Use the local copy of the config files from your repository to instantiate the generator/dataset classes. \ud83d\udcdd Paths : When using the dataset classes, ensure that the paths in your local configuration files are updated to correctly reference your dataset and seed files.","title":"4. Run the Generator"}]}